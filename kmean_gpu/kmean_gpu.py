# -*- coding: utf-8 -*-
"""kmean_gpu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r9AFgCd0907XvH6zyGGQdEpeOSSVxWuo
"""

import math

import pandas as pd
import numpy as np
# from numba import cuda
import time
import copy

df = pd.read_csv('../data/CC GENERAL.csv')

print(df.head())
print("======================")
print(df.isnull().sum())
print("======================")

df['MINIMUM_PAYMENTS'] = df['MINIMUM_PAYMENTS'].fillna(df['MINIMUM_PAYMENTS'].median())
df['CREDIT_LIMIT'] = df['CREDIT_LIMIT'].fillna(df['CREDIT_LIMIT'].mean())
print(df.isnull().sum())
print("======================")

df = df.drop('CUST_ID', axis=1)
np_data = df.to_numpy()
print(np_data.shape)
print("======================")

k = 20
centroid = np_data[np.random.randint(np_data.shape[0], size=k), :]


def next_power_of_2(x):
    return 1 << (x - 1).bit_length()


def calc_dimension_for_distance(data, data_centroid):
    real_dim_x = data_centroid.shape[0]
    dim_x = next_power_of_2(real_dim_x)
    dim_y = dim_x
    thread_per_blocks = (dim_x, dim_y)
    blocks_per_grid_x = 1
    blocks_per_grid_y = math.ceil(data.shape[0] / thread_per_blocks[0])
    blocks_per_grid = (blocks_per_grid_x, blocks_per_grid_y)
    return thread_per_blocks, blocks_per_grid


# dist_tpb, dist_bpg = calc_dimension_for_distance(np_data, centroid)


# print(dist_tpb)
#
# print(dist_bpg)


# @cuda.jit
# def calc_distance_kernel(data, data_centroid, result):
#     r = cuda.blockIdx.y * cuda.blockDim.y + cuda.threadIdx.y
#     c = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x
#     if r < data.shape[0] and c < data_centroid.shape[0]:
#         total = 0
#         for i in range(data_centroid.shape[1]):
#             total += math.pow(data[r][i] - data_centroid[c][i], 2)
#         result[r, c] = math.sqrt(total)


# dist_gpu_time_end = 0
# dist_gpu_time_start = 0


# def calc_distance_gpu(data, data_centroid):
#     result = np.zeros((data.shape[0], data_centroid.shape[0]))
#     data_device = cuda.to_device(data)
#     centroid_device = cuda.to_device(centroid)
#     result_device = cuda.to_device(result)
#
#     # invoke kernel
#     # global dist_gpu_time_end
#     # global dist_gpu_time_start
#     # dist_gpu_time_start = time.perf_counter()
#     calc_distance_kernel[dist_bpg, dist_tpb](data_device, centroid_device, result_device)
#     # dist_gpu_time_end = time.perf_counter()
#     result = result_device.copy_to_host()
#     return result


def calc_distance_cpu(data, data_centroid):
    dist = np.zeros((data.shape[0], data_centroid.shape[0]))
    for i in range(data.shape[0]):
        for j in range(data_centroid.shape[0]):
            dist[i][j] = np.linalg.norm(data[i] - data_centroid[j])
    return dist


# calculated_dist_gpu = calc_distance_gpu(np_data, centroid)
# dist_cpu_time_start = time.perf_counter()
# calculated_dist_cpu = calc_distance_cpu(np_data, centroid)
# dist_cpu_time_end = time.perf_counter()

# calculated_dist_gpu
#
# calculated_dist_gpu.shape
#
# dist_gpu_time_end - dist_gpu_time_start

# calculated_dist_cpu
#
# calculated_dist_cpu.shape

# dist_cpu_time_end - dist_cpu_time_start
#
# mse = (np.square(calculated_dist_cpu - calculated_dist_gpu)).mean()
#
# mse


def get_nearest_centroid(distance):
    return np.argmin(distance, axis=1)


def get_new_centroids(data, data_nearest_centroid, number_of_centroid):
    result_centroids = np.zeros((number_of_centroid, data.shape[1]))
    for i in range(number_of_centroid):
        result_centroids[i] = data[np.where(data_nearest_centroid == i)].mean(axis=0)
    return result_centroids


"""#CPU"""


def kmean_cpu(data, initial_centroid):
    centroid_cpu = copy.deepcopy(initial_centroid)
    iteration = 0
    has_changed_centroid = True
    total_time_start = time.perf_counter()
    while has_changed_centroid:
        iter_time_start = time.perf_counter()
        calc_dist_time_start = time.perf_counter()
        calculated_dist = calc_distance_cpu(data, centroid_cpu)  # calculated dist
        calc_dist_time_end = time.perf_counter()
        nearest_centroid_time_start = time.perf_counter()
        nearest_centroid = get_nearest_centroid(calculated_dist)  # assigned to centroid
        nearest_centroid_time_end = time.perf_counter()
        new_centroid = get_new_centroids(data, nearest_centroid, k)
        if np.all(new_centroid == centroid_cpu):
            has_changed_centroid = False
        else:
            # print(f"changed {np.linalg.norm(centroid - new_centroid)}")
            centroid_cpu = new_centroid
        iter_time_end = time.perf_counter()
        print(
            f"iter {iteration} | took: {iter_time_end - iter_time_start:0.4f} |"
            f" dist: {calc_dist_time_end - calc_dist_time_start:0.4f} | "
            f"nearest: {nearest_centroid_time_end - nearest_centroid_time_start:0.4f}")
        iteration += 1
    total_time_end = time.perf_counter()
    print("new centroids:")
    print(centroid_cpu)
    print(f"k: {k} | iteration took: {iteration} | total time: {total_time_end - total_time_start:0.4f}")


kmean_cpu(np_data, centroid)

"""#GPU"""

# iteration = 0
# has_changed_centroid = True
# total_time_start = time.perf_counter()
# while has_changed_centroid:
#     iter_time_start = time.perf_counter()
#     calc_dist_time_start = time.perf_counter()
#     calculated_dist = calc_distance_gpu(np_data, centroid)  # calculated dist
#     calc_dist_time_end = time.perf_counter()
#     nearest_centroid_time_start = time.perf_counter()
#     nearest_centroid = get_nearest_centroid(calculated_dist)  # assigned to centroid
#     nearest_centroid_time_end = time.perf_counter()
#     new_centroid = get_new_centroids(np_data, nearest_centroid, k)
#     if np.all(new_centroid == centroid):
#         has_changed_centroid = False
#     else:
#         # print(f"changed {np.linalg.norm(centroid - new_centroid)}")
#         centroid = new_centroid
#     iter_time_end = time.perf_counter()
#     print(
#         f"iter {iteration} | took: {iter_time_end - iter_time_start:0.4f} |"
#         f" dist: {calc_dist_time_end - calc_dist_time_start:0.4f} | "
#         f"nearest: {nearest_centroid_time_end - nearest_centroid_time_start:0.4f}")
#     iteration += 1
# total_time_end = time.perf_counter()
# # print("new centroids:")
# # print(centroid)
# print(f"k: {k} | iteration took: {iteration} | total time: {total_time_end - total_time_start:0.4f}")
